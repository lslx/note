

360加固分析。
最近看雪翻译了一片外文分析360加固的文章，并给出一些脚本。本文基于此文，试图验证并提取出工具用于逆向工程
工作。

文章地址：https://bbs.pediy.com/thread-225561.htm
原文地址：https://blog.zimperium.com/dissecting-mobile-native-code-packers-case-study/

文章概述了现存加固技术点，以及相应的破解方案和工具，然后集中焦点在对虚拟机保护的分析。
由于译文和原文都没有给出分析的apk，且文中提到vmp还原脚本没有达到产品化的要求，所以不能保证精确重现。
文中给出了两个py脚本，一个用于定位so初始化和退出函数，实际上用处不大，因为用readelf一个命令就可以拿到，用py是舍近求远。另一个py功能是还原vm字节码，转换成arm伪代码。

对比原文和译文，发现翻译存在不妥之处：
1. 源码多处引用展示了github代码，而译文中说图丢了然后让读者自行脑补。
2. 原文中对ITR.py的使用是提取壳so的入口信息，译文则说是修复so，由此可见译者并不是专业的逆向从业者。因为修复so背后必然隐藏着大量的技术细节（如如何变形保护，目的，如何还原）。中文读者误以为外层so自身有变形，当深入脚本寻找信息时候，却发现脚本仅仅提取了入口和初始化和退出函数的信息，没有修改任何东西。

原文所有重点都在说vmp，然而没有指明这个vmp保护的是什么。有两种可能，其一，保护客户dex的某些函数，其二，保护
壳自身代码不被逆向。从文章叙述的顺序，以及apk加固后的一般流程来判断，此vmp保护显然是为了保护内层so，（壳的so有两层，内层so是真正的功能性so，其加载不依赖于linker，而是自己实现的）使其难以跟踪调试。


原文的一些值得吐槽的地方：
1. 没有给出原包，想要根据文章精确重现变得不可能。
2. 砍掉一般性原理叙述，文章内容就短了一半，可以说废话很多。
3. 文章指出了反调原理（也许是参考了某中文文章，见下），而并未说明如何绕过。
4. 原文使用的样本较老，原文参考了一篇中文文章（发于freebuf：http://www.freebuf.com/articles/terminal/145102.html，样本已不可下载），后者使用了较新的版本。

鉴于原文，译文，以及相关引用中都没有找到可用样本，所以使用了前不久的某包来验证vmp还原脚本：
文中认为freebuf中的分析忽略了vmp部分的分析，作者猜想vmp部分可能在高版本中被清除了。
然而，我找出最近分析过的360加固apk（http://app.www.gov.cn/download/Chinese.html），分析发现vmp并没有清除。确认vmp指令部分如下：

于是可以使用vmp还原脚本验证可行性：



综上，文章唯一的价值在于给出了vmp还原脚本，但是此vmp并非加固中常说的vmp。我们常说的vmp是保护dex函数的vmp。
而文章中那个vmp是壳的so部分为了防止自身被逆向而做的加强。对于保护dex的那个vmp代码，文章分析的部分还远未达到，还需经过很多执行步骤。
